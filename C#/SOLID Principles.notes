START: 2021.01.04 - 10:17pm
SOLID Principle - Open/Closed:
    - Base - entities should be open for extension but closed to modification
    - It should be possible to change the behavior of a method without editing its source Consider
    - Simpler, more maintainable code and methods result
    - Balance abstraction and concreteness
        - Abstraction adds complexity
    - '"new" is glue'
    - How to predict future changes to find when abstraction is helpful:
        - Start concrete
        - Modify the code the first time or two
        - By third change, abstraction should be the go-forward
    - Typical approaches:
        - Parameters
        - Inheritance
        - Composition/Injection
        - Extensions
    - Prefer implementing new classes for new features
        - Allows you to build a  class that suits the problem at hand
        - Nothing in the system depends on it (yet)
        - Adds behavior without touching existing code
        - Can follow SRP (single responsibility principle)
        - Can be unit-tested
    - Switch cases can be considered for Factory refactor
    - Package design:
        - Closed for modification
            - Consumers cannot change package contents
            - Should not break consumers when new behavior is added
        - Open to extension
            - Can extend classes from package to add specific behavior to your app
    - Solve problem first, simply
    - Identify what changes the app will likely continue to need
    - Modify code to be extensible along the axis of change identified
        - WITHOUT the need to modify its source 
STOP: 2021.01.04 10:38pm
START: 2021.01.05 9:52pm
SOLID Principle - Interface Segregation Principle:
    - More dependencies:
        - More coupling
        - More brittle code
        - More difficult to test
        - More difficult deployments
    - Detecting ISP Violations in code
        - Large interfaces
        - NotImplementedExceptions
        - Code uses a small subset of a larger interface
    - Multiple Interface Inheritance in C#
        - Bigger interfaces can implement multiple smaller interfaces
    - EX:
        - Old/bad:
            - INotificationService
                - SendText()
                - SendEmail()
        - New/good:
            - IEmailService
                - Send()
            - ITextService
                - Send()
        - For existing code that uses INotificationService, we can use multiple inheritance:
            - Allows new code to use their specific interface
            - Allows old code to remain untouched.
    - Pain Driven Development
        - Use ISP to indentify what is causing pain points in app, then leverage ISP to solve the issues
    - Fixing ISP Violations
        - Break up large interfaces into smaller ones
            - Compose fat interfaces from smaller ones for backward compatibility (as described above)
        - If you can't control large interfaces you have to use
            - Create a small, cohesive interface
            - Use the adapter design pattern so code only has to interface with adapter that knows about the larger legacy interface
        - Clients should own and define their interfaces
    - Microsoft Reference Application + eBook:
        - github.com/dotnet-architecture/eShopOnWeb
    - Clean Architecture Solution Templates
        - github.com/ardalis/CleanArchitecture
STOP: 10:17pm
START: 2021.01.07 9:35pm
SOLID Principle - Dependency Inversion
    - High level modules should not depend on low-level modules
        - Both depend on abstractions
    - Abstractions should not depend on details, details should depend on abstractions
    - Dependencies in C#
        - Compile-time
        - Run-time
    - Related PluralSight courses:
        - "Creating N-Tier Applications in C#"
        - "Domain-Driven Design Fundamentals"
    - High level
        - Process oriented, not detail oriented
        - Further from I/O (DB, files, input, etc.)
    - Low level
        - "Plumbing" code
        - Closer to I/O
        - How software interacts with external systems and hardware
    - Abstractions in C#
        - interfaces
        - Abstract base classes
        - Types you can't instantiate
    - Details and Abstractions
        - Abstractions should not be couple to details
        - Abstractions describe WHAT
            - Send a message
            - Store a Customer record
        - Details specify HOW
            - Send an SMTP email over port 25
            - Serialize customer to JSON and store as text file
    - NEW is GLUE
    - Explicit dependencies Principle
        - Classes should not surprise clients with dependences
        - Classes should list dependencies up front in constructor
    - Abstractions should not leak details
    - Most classes should depend on the abstractions, not the implementation details
    - Classes should be explicit about their dependencies
    - Clients should inject dependencies when they create other classes
SOLID Principles Review:
    - Single responsibility <-> Interface Segregation - promotes small cohesive Types
    - Interface Segregation <-> Liskov Substitution - Interfaces must be FULLY implemented
    - SR <-> Open/Close <-> Interface Segregation - Add functionality by adding more classes
    - Open/Close <-> Dependency Inversion - Change behavior by passing in different dependencies
    - Interface Segregation <-> Dependency Inversion - Details depend on interfaces
STOP: 10:17pm
START: 2021.01.08 10:50pm
SOLID Principle - Single Responsibility Principles
    - Single Responsibility Principle
        - Uncle Bob
        - Each software module (class, function, etc.) should have one and only one reason to change
    - Separate the WHAT from the HOW
    - What is a Responsibility?
        - Persistence, logging, validation, biz logic
    - Responsibilites change at different times for different reasons
    - "Axes of change" - the ways in which your app may change
    - Class elements should belong together, cohesion
STOP: 11:05pm